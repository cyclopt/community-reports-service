import fs from "node:fs";

import sgMail from "@sendgrid/mail";
import base64url from "base64url";
import bodyParser from "body-parser";
import chalk from "chalk";
import cors from "cors";
import dayjs from "dayjs";
import { deleteAsync } from "del";
import * as dotenv from "dotenv";
import express from "express";
import { glob } from "glob";

import api from "./api/index.js";
import { getProjectReport, getOfferReport, getVulnerabilitiesReport, getTddReport, getNis2Report } from "./components/index.js";

dotenv.config();

const { PORT, SENDGRID_API_KEY } = process.env;

sgMail.setApiKey(SENDGRID_API_KEY);

const app = express();
app.use(cors({ credentials: true, origin: true }));
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: false, limit: "10mb" }));
app.use(bodyParser.json());

app.get("/test", (_, res) => res.send("don't test me buddy ðŸ˜ "));

const deletePngFiles = async (type) => {
	try {
		const files = await glob(`src/components/${type}-report/tmp-graph-forlder/*.png`); // Get all .png files in the current directory

		for (const file of files) {
			deleteAsync(file, { force: true });
		}
	} catch { /* */}
};

app.post("/project-report", async (req, res) => {
	try {
		const {
			token,
			projectId,
			projectIds = [projectId],
			date,
			emails,
			criticalViolations = false,
			hostingFacility,
			bcc,
			fileName,
		} = req.body;
		const data = [];

		if (!hostingFacility || !token || (!projectId && projectIds.length === 0)) return res.send("Query parameters not provided");

		if (projectIds.length > 0) {
			const projectsS = await Promise.all(projectIds.map(async (prID) => {
				try {
					const project = await api(token).get(`projects/${prID}`).json();
					return ({ ...project, hostingFacility });
				} catch {
					return null;
				}
			}));
			const projects = projectsS?.filter((p) => p !== null);
			const repoKeys = projects.flatMap((p) => p.linkedRepositories)?.reduce((prev, cur) => {
				if (prev?.some((rK) => (
					rK.name === cur?.name
					&& rK.owner === cur?.owner
					&& rK.root === cur?.root
					&& rK.language === cur?.language
					&& (rK?.csProjects?.length > 0 ? (rK?.csProjects === cur?.csProjects) : true)
				))) return prev;
				return [
					...prev,
					{
						name: cur?.name,
						owner: cur?.owner,
						root: cur?.root,
						language: cur?.language,
						...(cur?.csProjects?.length > 0 ? { csProjects: cur?.csProjects } : {}),
					}];
			}, []);

			for (const repoKey of repoKeys) {
				const correspondingProject = projects.find((p) => (
					p.linkedRepositories.some((r) => (
						r.name === repoKey.name
						&& r.owner === repoKey.owner
						&& r.root === repoKey.root
						&& r.language === repoKey.language
						&& (r?.csProjects?.length > 0 ? (r?.csProjects === repoKey?.csProjects) : true)
					))
				));
				if (correspondingProject) {
					const analyses = await api(token).get("reports/analyses", {
						searchParams: {
							projectId: correspondingProject?._id,
							date: date || dayjs().subtract(14, "day").startOf("day").format("MM/DD/YYYY"),
							name: repoKey.name,
							owner: repoKey.owner,
							language: repoKey.language,
							root: repoKey.root,
							// Check if repoKey.csProjects exists before adding it to the searchParams
							...(repoKey?.csProjects?.length > 0 && { csProjects: JSON.stringify(repoKey.csProjects) }),
						},
					}).json();

					let lastCommit = { authoredAt: dayjs().year(2000) };
					let firstCommit = { authoredAt: dayjs() };

					if (analyses?.length > 0) {
						for (const analysis of analyses) {
							const c = analysis?.commit;

							// this check is for AimmsMVC and Services
							if (c !== undefined) {
								const curCommitDate = dayjs(c?.authoredAt);

								if (curCommitDate.isAfter(lastCommit?.authoredAt)) lastCommit = c;
								if (curCommitDate.isBefore(firstCommit?.authoredAt)) firstCommit = c;
							}
						}

						data.push({ ...repoKey, lastCommit, firstCommit, analyses });
					}
				}
			}

			if (data.length > 0) {
				if (emails?.length > 0) {
					const projectReport = await getProjectReport(projects, data, { criticalViolations }, date, false, fileName);
					const msg = {
						from: "noreply@cyclopt.com",
						to: emails,
						...((bcc?.length > 0) && { bcc }),
						subject: `${fileName || projects.map((p) => p.name)?.join(",")} Â· Cyclopt Report`,
						text: `Software Quality Evaluation Report\n\nGenerated by Cyclopt\n\n ${fileName || projects.map((p) => p.name)?.join(",")}`,
						attachments: [
							{
								content: projectReport,
								filename: `${fileName || projects.map((p) => p.name)?.join(",")}.pdf`,
								type: "application/pdf",
								disposition: "attachment",
							},
						],
					};
					await sgMail.send(msg);

					return res.json({ success: true });
				}

				const projectReport = await getProjectReport(projects, data, { criticalViolations }, date, true, fileName);
				res.setHeader("Content-Type", "application/pdf");
				res.setHeader("Content-Disposition", `attachment; filename=${fileName || projects.map((p) => p.name)?.join(",")}.pdf`);
				return projectReport.pipe(res);
			}
		}

		return res.json({ success: false });
	} catch {
		const { clients } = req.body;
		const errorNotificationToUser = {
			from: "noreply@cyclopt.com",
			to: clients?.user?.email,
			subject: "Error occurred while sending Cyclopt Report",
			text: "An error occurred while sending the Cyclopt Report:\n\nOur team will review the error and provide an updated report.",
		};
		try {
			await sgMail.send(errorNotificationToUser);
		} catch (error_) {
			console.error("Error occurred while sending error notification:", error_.message);
		}

		return res.status(500).json({ message: "Something went wrong." });
	}
});

app.post("/tdd-report", async (req, res) => {
	const {
		violations = {},
		vulnerabilities = {},
		sast = {},
		metrics = {},
		finalSections,
		owner,
		hash,
		name,
		llmResponseForViolations: vioResponse,
		llmResponseForSecurityViolations: secVioResponse,
		llmResponseForVulnerabilities: vulResponse,
		llmMaintainabilityResponse: mainResponse,
		llmSastResponse: sastResponse,
		llmResponseForConclusion: conclusionResponse,
		edit = false,
		fileName = null,
		tddId = "",
		token,
	} = req.body;
	try {
		const {
			report,
			llmResponseForViolations,
			llmResponseForSecurityViolations,
			llmResponseForVulnerabilities,
			llmMaintainabilityResponse,
			llmSastResponse,
			llmResponseForConclusion,
			sastGraphPath,
			vulnerabilityGraphPath,
			violationsGraphPath,
			securityViolationsGraphPath,
		} = await getTddReport(violations,
			vulnerabilities,
			sast,
			metrics,
			finalSections,
			owner,
			name,
			hash,
			fileName,
			vioResponse,
			secVioResponse,
			vulResponse,
			mainResponse,
			sastResponse,
			conclusionResponse,
			edit,
			token,
			tddId);

		// send png back to server to save them in the cloud
		const sastGraphPng = sastGraphPath ? (fs.readFileSync(sastGraphPath)) : null;
		const finalSastGraphPng = sastGraphPng ? Buffer.from(sastGraphPng).toString("base64") : null;

		const vulGraphPng = vulnerabilityGraphPath ? (fs.readFileSync(vulnerabilityGraphPath)) : null;
		const finalVulGraphPng = vulGraphPng ? Buffer.from(vulGraphPng).toString("base64") : null;

		const vioGraphPng = violationsGraphPath ? (fs.readFileSync(violationsGraphPath)) : null;
		const finalVioGraphPng = vioGraphPng ? Buffer.from(vioGraphPng).toString("base64") : null;

		const secVioGraphPng = securityViolationsGraphPath ? (fs.readFileSync(securityViolationsGraphPath)) : null;
		const finalSecVioGraphPng = secVioGraphPng ? Buffer.from(secVioGraphPng).toString("base64") : null;

		await deletePngFiles("tdd");

		return res.status(200).json({
			message: "ok",
			report,
			llmResponseForViolations,
			llmResponseForSecurityViolations,
			llmResponseForVulnerabilities,
			llmMaintainabilityResponse,
			llmSastResponse,
			llmResponseForConclusion,
			finalSastGraphPng,
			finalVulGraphPng,
			finalVioGraphPng,
			finalSecVioGraphPng,
		});
	} catch (error) {
		console.log(error);
		return res.status(500).json({ message: error.message });
	}
});

app.post("/nis2-report", async (req, res) => {
	const {
		violations = {},
		vulnerabilities = {},
		sast = {},
		nis2Practices = {},
		finalSections,
		llmResponseForSecurityViolations: secVioResponse,
			 llmResponseForVulnerabilities: vulResponse,
		llmSastResponse: sastResponse,
		llmResponseForPractices: practicesResponse,
		llmResponseForConclusion: conclusionResponse,
		edit = false,
		fileName = null,
		questionnaireName = "",
		nis2Id = "",
		token,
	} = req.body;
	try {
		const {
			report,
			llmResponseForSecurityViolations,
			llmResponseForVulnerabilities,
			llmSastResponse,
			llmResponseForPractices,
			llmResponseForConclusion,
			sastGraphPath,
			vulnerabilityGraphPath,
			securityViolationsGraphPath,
			practicesGraphPath,
		} = await getNis2Report(
			violations,
			vulnerabilities,
			sast,
			nis2Practices,
			finalSections,
			fileName,
			questionnaireName,
			secVioResponse,
			vulResponse,
			sastResponse,
			practicesResponse,
			conclusionResponse,
			edit,
			token,
			nis2Id,
			false,
		);

		// send png back to server to save them in the cloud
		const sastGraphPng = sastGraphPath ? (fs.readFileSync(sastGraphPath)) : null;
		const finalSastGraphPng = sastGraphPng ? Buffer.from(sastGraphPng).toString("base64") : null;

		const vulGraphPng = vulnerabilityGraphPath ? (fs.readFileSync(vulnerabilityGraphPath)) : null;
		const finalVulGraphPng = vulGraphPng ? Buffer.from(vulGraphPng).toString("base64") : null;

		const secVioGraphPng = securityViolationsGraphPath ? (fs.readFileSync(securityViolationsGraphPath)) : null;
		const finalSecVioGraphPng = secVioGraphPng ? Buffer.from(secVioGraphPng).toString("base64") : null;

		const practicesGraphPng = practicesGraphPath ? (fs.readFileSync(practicesGraphPath)) : null;
		const finalPracticesGraphPng = practicesGraphPng ? Buffer.from(practicesGraphPng).toString("base64") : null;

		await deletePngFiles("nis2");

		return res.status(200).json({
			message: "ok",
			report,
			llmResponseForSecurityViolations,
			llmResponseForVulnerabilities,
			llmSastResponse,
			llmResponseForPractices,
			llmResponseForConclusion,
			finalSastGraphPng,
			finalVulGraphPng,
			finalSecVioGraphPng,
			finalPracticesGraphPng,
		});
	} catch (error) {
		return res.status(500).json({ message: error.message });
	}
});

app.post("/vulnerabilities-report", async (req, res) => {
	try {
		const {
			token,
			projectId,
			projectIds = [projectId],
			emails,
			hostingFacility,
			bcc,
			fileName = "",
		} = req.body;
		const data = [];

		if (!hostingFacility || !token || (!projectId && projectIds.length === 0)) return res.send("Query parameters not provided");

		if (projectIds.length > 0) {
			const projectsS = await Promise.all(projectIds.map(async (prID) => {
				try {
					const project = await api(token).get(`projects/${prID}`).json();
					return ({ ...project, hostingFacility });
				} catch {
					return null;
				}
			}));
			const projects = projectsS?.filter((p) => p !== null);
			const repoKeys = projects.flatMap((p) => p.linkedRepositories)?.reduce((prev, cur) => {
				if (prev?.some((rK) => (
					rK.name === cur?.name
					&& rK.owner === cur?.owner
					&& rK.root === cur?.root
					&& rK.language === cur?.language
					&& (rK?.csProjects?.length > 0 ? (rK?.csProjects === cur?.csProjects) : true)
				))) return prev;
				return [
					...prev,
					{
						name: cur?.name,
						owner: cur?.owner,
						root: cur?.root,
						language: cur?.language,
						...(cur?.csProjects?.length > 0 ? { csProjects: cur?.csProjects } : {}),
					}];
			}, []);

			for (const repoKey of repoKeys) {
				const correspondingProject = projects.find((p) => (
					p.linkedRepositories.some((r) => (
						r.name === repoKey.name
						&& r.owner === repoKey.owner
						&& r.root === repoKey.root
						&& r.language === repoKey.language
						&& (r?.csProjects?.length > 0 ? (r?.csProjects === repoKey?.csProjects) : true)
					))
				));

				if (correspondingProject) {
					const analyses = await api(token).get("reports/last-analyses", {
						searchParams: {
							projectId: correspondingProject?._id,
							name: repoKey.name,
							owner: repoKey.owner,
							language: repoKey.language,
							root: repoKey.root,
							...(repoKey?.csProjects?.length > 0 && { csProjects: JSON.stringify(repoKey.csProjects) }),
						},
					}).json();

					let lastCommit = { authoredAt: dayjs().year(2000) };

					if (analyses?.length > 0) {
						for (const analysis of analyses) {
							const c = analysis?.commit;
							const curCommitDate = dayjs(c?.authoredAt);

							if (curCommitDate.isAfter(lastCommit?.authoredAt)) lastCommit = c;
						}

						data.push({ ...repoKey, lastCommit, analyses });
					}
				}
			}

			if (data.length > 0) {
				if (emails?.length > 0) {
					const securityReport = await getVulnerabilitiesReport(projects, data, false, fileName);
					const msg = {
						from: "noreply@cyclopt.com",
						to: emails,
						...((bcc?.length > 0) && { bcc }),
						subject: `${fileName || projects.map((p) => p.name)?.join(",")} Â· Cyclopt Report`,
						text: `Software Security Report\n\nGenerated by Cyclopt\n\n ${fileName || projects.map((p) => p.name)?.join(",")}`,
						attachments: [
							{
								content: securityReport,
								filename: `${fileName || projects.map((p) => p.name)?.join(",")}.pdf`,
								type: "application/pdf",
								disposition: "attachment",
							},
						],
					};
					await sgMail.send(msg);

					console.log(`email sent to: ${chalk.italic.green(`[${emails.map((e) => e)}]`)} - report name: ${fileName || projects.map((p) => p.name)?.join(",")}`);
					return res.json({ success: true });
				}

				const projectReport = await getVulnerabilitiesReport(projects, data, true, fileName);
				res.setHeader("Content-Type", "application/pdf");
				res.setHeader("Content-Disposition", `attachment; filename=${fileName || projects.map((p) => p.name)?.join(",")}.pdf`);
				return projectReport.pipe(res);
			}

			console.log(`${chalk.italic.yellow("no analyses")} found for ${chalk.italic.magenta(fileName)}`);
		}

		return res.json({ success: false });
	} catch (error) {
		console.log(error);
		return res.status(500).json({ message: "Something went wrong." });
	}
});

app.get("/download-offer-report", async (req, res) => {
	try {
		const { plan, languages, totalSeats } = JSON.parse(base64url.decode(req.query.encodedPayload));

		const data = {
			plan,
			languages,
			totalSeats,
		};
		const offerReport = await getOfferReport(data, true);
		res.setHeader("Content-Type", "application/pdf");
		res.setHeader("Content-Disposition", "attachment; filename=cyclopt-proposal.pdf");
		return offerReport.pipe(res);
	} catch {
		return res.status(500).json({ message: "Something went wrong." });
	}
});

app.use("/", (_, res) => res.send("Hello there ðŸ˜Ž"));

const port = PORT || 5000;
app.listen(port, () => console.log(chalk.bold.magenta(`Server running on: http://localhost:${port}`)));
